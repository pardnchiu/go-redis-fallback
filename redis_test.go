/*
 * Test code generated by GitHub Copilot with Claude 4
 */
package redisFallback

import (
	"context"
	"fmt"
	"sync"
	"testing"
	"time"
)

// 測試基本操作
func TestBasicOperations(t *testing.T) {
	cache := setupTestCache(t)
	defer cache.Close()

	t.Run("字串操作", func(t *testing.T) {
		err := cache.Set("test:string", "Hello Redis Fallback", 10*time.Minute)
		if err != nil {
			t.Errorf("設定字串失敗: %v", err)
		}

		value, err := cache.Get("test:string")
		if err != nil {
			t.Errorf("取得字串失敗: %v", err)
		}
		if value != "Hello Redis Fallback" {
			t.Errorf("字串值不符，預期: Hello Redis Fallback, 實際: %v", value)
		}
	})

	t.Run("數值操作", func(t *testing.T) {
		err := cache.Set("test:integer", 42, 5*time.Minute)
		if err != nil {
			t.Errorf("設定整數失敗: %v", err)
		}

		value, err := cache.Get("test:integer")
		if err != nil {
			t.Errorf("取得整數失敗: %v", err)
		}
		if value != 42 {
			t.Errorf("整數值不符，預期: 42, 實際: %v", value)
		}
	})

	t.Run("浮點數操作", func(t *testing.T) {
		err := cache.Set("test:float", 3.14159, 5*time.Minute)
		if err != nil {
			t.Errorf("設定浮點數失敗: %v", err)
		}

		value, err := cache.Get("test:float")
		if err != nil {
			t.Errorf("取得浮點數失敗: %v", err)
		}
		if value != 3.14159 {
			t.Errorf("浮點數值不符，預期: 3.14159, 實際: %v", value)
		}
	})

	t.Run("布林值操作", func(t *testing.T) {
		err := cache.Set("test:boolean", true, 5*time.Minute)
		if err != nil {
			t.Errorf("設定布林值失敗: %v", err)
		}

		value, err := cache.Get("test:boolean")
		if err != nil {
			t.Errorf("取得布林值失敗: %v", err)
		}
		if value != true {
			t.Errorf("布林值不符，預期: true, 實際: %v", value)
		}
	})
}

// 測試 TTL 操作
func TestTTLOperations(t *testing.T) {
	cache := setupTestCache(t)
	defer cache.Close()

	t.Run("短期TTL", func(t *testing.T) {
		err := cache.Set("test:ttl:short", "expires soon", 2*time.Second)
		if err != nil {
			t.Errorf("設定短期TTL失敗: %v", err)
		}

		// 立即驗證資料存在
		value, err := cache.Get("test:ttl:short")
		if err != nil {
			t.Errorf("立即取得短期TTL資料失敗: %v", err)
		}
		if value != "expires soon" {
			t.Errorf("短期TTL值不符，預期: expires soon, 實際: %v", value)
		}

		// 等待過期
		time.Sleep(3 * time.Second)

		// 驗證資料已過期
		_, err = cache.Get("test:ttl:short")
		if err == nil {
			t.Error("短期TTL資料應該已過期")
		}
		if err.Error() != "Not found" {
			t.Errorf("過期錯誤訊息不符，預期: Not found, 實際: %v", err.Error())
		}
	})

	t.Run("永久資料", func(t *testing.T) {
		err := cache.Set("test:ttl:permanent", "never expires", 0)
		if err != nil {
			t.Errorf("設定永久資料失敗: %v", err)
		}

		value, err := cache.Get("test:ttl:permanent")
		if err != nil {
			t.Errorf("取得永久資料失敗: %v", err)
		}
		if value != "never expires" {
			t.Errorf("永久資料值不符，預期: never expires, 實際: %v", value)
		}
	})

	t.Run("長期TTL", func(t *testing.T) {
		err := cache.Set("test:ttl:long", "expires later", 1*time.Hour)
		if err != nil {
			t.Errorf("設定長期TTL失敗: %v", err)
		}

		value, err := cache.Get("test:ttl:long")
		if err != nil {
			t.Errorf("取得長期TTL資料失敗: %v", err)
		}
		if value != "expires later" {
			t.Errorf("長期TTL值不符，預期: expires later, 實際: %v", value)
		}
	})
}

// 測試複雜資料類型
func TestComplexDataTypes(t *testing.T) {
	cache := setupTestCache(t)
	defer cache.Close()

	t.Run("使用者資料結構", func(t *testing.T) {
		userData := map[string]interface{}{
			"id":       1001,
			"username": "johndoe",
			"email":    "john.doe@example.com",
			"age":      28,
			"active":   true,
			"tags":     []string{"developer", "golang", "redis"},
			"metadata": map[string]interface{}{
				"last_login":  time.Now().Unix(),
				"login_count": 42,
				"preferences": []string{"dark_mode", "notifications"},
			},
		}

		err := cache.Set("test:user:complex", userData, 15*time.Minute)
		if err != nil {
			t.Errorf("設定複雜使用者資料失敗: %v", err)
		}

		value, err := cache.Get("test:user:complex")
		if err != nil {
			t.Errorf("取得複雜使用者資料失敗: %v", err)
		}
		if value == nil {
			t.Error("複雜使用者資料不應為空")
		}
	})

	t.Run("產品列表", func(t *testing.T) {
		products := []map[string]interface{}{
			{"id": 1, "name": "Laptop", "price": 999.99, "in_stock": true},
			{"id": 2, "name": "Mouse", "price": 29.99, "in_stock": false},
			{"id": 3, "name": "Keyboard", "price": 79.99, "in_stock": true},
		}

		err := cache.Set("test:products:list", products, 20*time.Minute)
		if err != nil {
			t.Errorf("設定產品列表失敗: %v", err)
		}

		value, err := cache.Get("test:products:list")
		if err != nil {
			t.Errorf("取得產品列表失敗: %v", err)
		}
		if value == nil {
			t.Error("產品列表不應為空")
		}
	})

	t.Run("巢狀設定結構", func(t *testing.T) {
		config := map[string]interface{}{
			"app": map[string]interface{}{
				"name":    "MyApp",
				"version": "1.0.0",
				"features": map[string]bool{
					"analytics": true,
					"debugging": false,
					"caching":   true,
				},
			},
			"database": map[string]interface{}{
				"host": "localhost",
				"port": 5432,
				"connections": map[string]int{
					"max_idle": 10,
					"max_open": 100,
				},
			},
		}

		err := cache.Set("test:config:nested", config, 30*time.Minute)
		if err != nil {
			t.Errorf("設定巢狀設定失敗: %v", err)
		}

		value, err := cache.Get("test:config:nested")
		if err != nil {
			t.Errorf("取得巢狀設定失敗: %v", err)
		}
		if value == nil {
			t.Error("巢狀設定不應為空")
		}
	})
}

// 測試批次操作
func TestBatchOperations(t *testing.T) {
	cache := setupTestCache(t)
	defer cache.Close()

	batchSize := 50 // 減少測試數量避免超時
	start := time.Now()

	// 批次設定操作
	for i := 0; i < batchSize; i++ {
		key := fmt.Sprintf("test:batch:item:%d", i)
		value := map[string]interface{}{
			"id":        i,
			"name":      fmt.Sprintf("Item %d", i),
			"timestamp": time.Now().Unix(),
			"batch_id":  "batch_001",
		}

		err := cache.Set(key, value, 30*time.Minute)
		if err != nil {
			t.Errorf("設定批次項目 %d 失敗: %v", i, err)
		}
	}

	elapsed := time.Since(start)
	t.Logf("批次設定 %d 個項目耗時: %v", batchSize, elapsed)

	// 驗證隨機樣本
	testIndices := []int{5, 15, 25, 35, 45}
	for _, idx := range testIndices {
		if idx >= batchSize {
			continue
		}
		key := fmt.Sprintf("test:batch:item:%d", idx)
		value, err := cache.Get(key)
		if err != nil {
			t.Errorf("驗證批次項目 %d 失敗: %v", idx, err)
		}
		if value == nil {
			t.Errorf("批次項目 %d 不應為空", idx)
		}
	}
}

// 測試併發操作
func TestConcurrentOperations(t *testing.T) {
	cache := setupTestCache(t)
	defer cache.Close()

	numWorkers := 20 // 減少併發數量避免超時
	var wg sync.WaitGroup
	errors := make(chan error, numWorkers)

	start := time.Now()

	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()

			key := fmt.Sprintf("test:concurrent:worker:%d", workerID)
			value := map[string]interface{}{
				"worker_id": workerID,
				"timestamp": time.Now().UnixNano(),
				"data":      fmt.Sprintf("Concurrent data from worker %d", workerID),
			}

			// 設定操作
			if err := cache.Set(key, value, 25*time.Minute); err != nil {
				errors <- fmt.Errorf("worker %d 設定失敗: %v", workerID, err)
				return
			}

			// 立即讀取驗證
			if _, err := cache.Get(key); err != nil {
				errors <- fmt.Errorf("worker %d 讀取失敗: %v", workerID, err)
			}
		}(i)
	}

	wg.Wait()
	close(errors)
	elapsed := time.Since(start)

	errorCount := 0
	for err := range errors {
		t.Error(err)
		errorCount++
	}

	if errorCount == 0 {
		t.Logf("併發操作 %d 個工作者成功完成，耗時: %v", numWorkers, elapsed)
	}
}

// 測試刪除操作
func TestDeleteOperations(t *testing.T) {
	cache := setupTestCache(t)
	defer cache.Close()

	testKeys := []string{
		"test:delete:string",
		"test:delete:number",
		"test:delete:object",
	}

	// 設定測試資料
	for i, key := range testKeys {
		value := fmt.Sprintf("Delete test data %d", i)
		err := cache.Set(key, value, 10*time.Minute)
		if err != nil {
			t.Errorf("設定刪除測試資料失敗: %v", err)
			continue
		}
	}

	// 驗證資料存在
	for _, key := range testKeys {
		_, err := cache.Get(key)
		if err != nil {
			t.Errorf("刪除前資料不存在: %s", key)
		}
	}

	// 執行刪除
	for _, key := range testKeys {
		err := cache.Del(key)
		if err != nil {
			t.Errorf("刪除 %s 失敗: %v", key, err)
		}
	}

	// 驗證資料已刪除
	for _, key := range testKeys {
		_, err := cache.Get(key)
		if err == nil {
			t.Errorf("刪除後資料仍存在: %s", key)
		}
		if err.Error() != "Not found" {
			t.Errorf("刪除後錯誤訊息不符，預期: Not found, 實際: %v", err.Error())
		}
	}
}

// 測試錯誤處理
func TestErrorHandling(t *testing.T) {
	cache := setupTestCache(t)
	defer cache.Close()

	t.Run("取得不存在的鍵", func(t *testing.T) {
		_, err := cache.Get("test:nonexistent:key")
		if err == nil {
			t.Error("不存在的鍵應該回傳錯誤")
		}
		if err.Error() != "Not found" {
			t.Errorf("錯誤訊息不符，預期: Not found, 實際: %v", err.Error())
		}
	})

	t.Run("刪除不存在的鍵", func(t *testing.T) {
		err := cache.Del("test:nonexistent:delete")
		if err != nil {
			t.Errorf("刪除不存在的鍵不應出錯: %v", err)
		}
	})
}

// 測試降級模式 (手動測試用)
func TestFallbackMode(t *testing.T) {
	if testing.Short() {
		t.Skip("跳過降級模式測試 (使用 -short 旗標)")
	}

	cache := setupTestCache(t)
	defer cache.Close()

	t.Log("降級模式測試開始，持續 10 秒")
	t.Log("請在測試期間手動停止/重啟 Redis 以測試降級功能")

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	counter := 0
	successCount := 0
	failCount := 0

	for {
		select {
		case <-ctx.Done():
			t.Logf("降級模式測試完成 - 成功: %d, 失敗: %d", successCount, failCount)
			return
		case <-ticker.C:
			counter++
			key := fmt.Sprintf("test:fallback:entry:%d", counter)
			value := map[string]interface{}{
				"counter":   counter,
				"timestamp": time.Now().Format("2006-01-02 15:04:05"),
				"message":   fmt.Sprintf("Fallback test entry #%d", counter),
			}

			// 寫入操作
			writeErr := cache.Set(key, value, 30*time.Minute)
			if writeErr != nil {
				failCount++
				t.Logf("[%d] 寫入失敗: %v", counter, writeErr)
			} else {
				successCount++
			}

			// 讀取操作
			_, readErr := cache.Get(key)
			if readErr != nil {
				t.Logf("[%d] 讀取失敗: %v", counter, readErr)
			}
		}
	}
}

// 設定測試快取實例
func setupTestCache(t *testing.T) *RedisFallback {
	config := Config{
		Redis: &Redis{
			Host:     "localhost",
			Port:     6379,
			Password: "0123456789",
			DB:       0,
		},
		Log: &Log{
			Stdout: false, // 測試時關閉標準輸出
		},
	}

	cache, err := New(config)
	if err != nil {
		t.Fatalf("建立快取實例失敗: %v", err)
	}

	return cache
}
